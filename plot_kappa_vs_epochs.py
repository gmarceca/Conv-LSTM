import matplotlib.pyplot as  plt
from glob import glob
import numpy as np
from collections import defaultdict

def get_kappa_from_local(exp):
    '''
    This function reads txt generated by running
    lstm_scores.py. This txt contains the predictions
    for one specific machine only on a per shot basis
    '''

    path = glob('./experiments/{}/kappa_scores_exp_{}_epoch_*_JET_1p6khz.txt'.format(exp, exp))
    L_score_jet = []
    D_score_jet = []
    H_score_jet = []
    Avg_score_jet = []
    epochs = []
    for p in path:
        ep = int(p.split('_')[-3])
        epochs.append(ep)
        with open(p, "r") as f:
            lines = f.read().splitlines()
            line = lines[-1]
            vals = line[1:-2].split(' ')
            vals = list(filter(None, vals))
            #print(vals)
            L_score_jet.append(float(vals[0]))
            D_score_jet.append(float(vals[1]))
            H_score_jet.append(float(vals[2]))
            Avg_score_jet.append(float(vals[3]))
        pass

    # return the values in sorted order
    idx = np.argsort(epochs)
    epochs = np.array(epochs)[idx]
    if Avg_score_jet:
        Avg_score_jet = np.array(Avg_score_jet)[idx]
    return epochs, Avg_score_jet

def get_kappa_from_cullback(exp):
    '''
    This function reads the txt generated by the custom cullback.
    The txt contains the avg predictions for maximum two devices.
    '''
    path = glob('./experiments/{}/kappa_scores_exp_{}_epoch_*.txt'.format(exp, exp))
    # Filter all list elements that contain 1p6khz string on it
    path = list(filter(lambda l: '1p6khz' not in l, path))
    
    L_score = defaultdict(list)
    D_score = defaultdict(list)
    H_score = defaultdict(list)
    Avg_score = defaultdict(list)
    epochs = []
    for p in path:
        ep = int(p.split('_')[-1][:-4])
        epochs.append(ep)
        f = open(p, "r")
        key_ = ''
        for position, line in enumerate(f):
            if 'TCV' in line:
                key_ = 'TCV'
            elif 'JET' in line:
                key_ = 'JET'
            elif 'AUG' in line:
                key_ = 'AUG'
            # Continue until last line of TCV shots
            if line[0] == 's': #(is a shot)
                continue
            elif line[0] == '[': # average kappa
                vals = line[1:-2].split(' ')
                vals = list(filter(None, vals))
                L_score[key_].append(float(vals[0]))
                D_score[key_].append(float(vals[1]))
                H_score[key_].append(float(vals[2]))
                Avg_score[key_].append(float(vals[3]))
        pass
    
    # return the values in sorted order
    idx = np.argsort(epochs)
    epochs = np.array(epochs)[idx]
    if Avg_score['TCV']:
        Avg_score['TCV'] = np.array(Avg_score['TCV'])[idx]
    if Avg_score['JET']:
        Avg_score['JET'] = np.array(Avg_score['JET'])[idx]
    if Avg_score['AUG']:
        Avg_score['AUG'] = np.array(Avg_score['AUG'])[idx]
    return np.argsort(epochs), Avg_score

def main():
    
    #epochs, Avg_score_tcv, Avg_score_aug = get_kappa_from_cullback('TCV2AUG_v4')
    #epochs, Avg_score_m1, Avg_score_m2 = get_kappa_from_cullback('TCV2JET_GWfr_v16')
    epochs, Avg_score = get_kappa_from_cullback('TCV2AUGJET_gwfr_pd_wp_zGCS_v21')
    epochs_jetbs, Avg_score_jetbs = get_kappa_from_cullback('JET_baseline')
    
    plt.plot(epochs, Avg_score['TCV'], color='blue')
    plt.plot(epochs, Avg_score['JET'], color='red')
    plt.plot(epochs, Avg_score['AUG'], color='green')
    plt.plot(epochs_jetbs, Avg_score_jetbs['JET'], color='red', linestyle='dashed')

    plt.yticks(np.arange(0, 1, 0.1))
    
    #horiz_line_data = np.arange(-1, 100, 1)
    #plt.plot(horiz_line_data, np.ones(len(horiz_line_data))*0.27, 'r--')

    plt.xlim([-1, 110])
    plt.ylim([0, 1])

    plt.xlabel('epochs')
    plt.ylabel('Kappa')
    plt.title('ConvLSTM')
    plt.legend(('TCV 10khz', 'TCV --> JET 1.6khz', 'TCV --> AUG', 'JET baseline'), loc = 'best')

    plt.savefig('CNNLSTM_model_kappa_vs_epochs_TCV2AUGJET_gwfr_pd_wp_zGCS_v21.png')
    pass

if __name__ == '__main__':
    main()
